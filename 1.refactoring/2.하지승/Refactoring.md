# Refactoring
**``한번에 하나씩``**
**``신뢰성 높은 테스팅은 필수``**
- - -
```
UML (Unified Modeling Language)
● 객체간의 관계를 표현하는데 주로 사용.
● 시스템 시각화, 사양 및 설계를 문서화할 때 사용하는 표현 방법
UML의 속성 = java의 필드
UML 조작 = java의 메서드이라고 생각하면 된다.
```
## 01.리팩토링이란?
*외부에서 보는 프로그램 동작은 바꾸지 않고 프로그램의 내부 구조를 개선하는 것*

>동작이 변하지 않았나 확인하는것 => 유닛테스트(단위테스트)

#### 리팩토링의 목적
1. 버그를 발견하기 쉽게 만든다.
2. 기능을 추가하기 쉽게 만든다.
3. 리뷰하기 쉽게 만든다.


#### 리팩토링의 한계
1. 프로그램이 아직 동작하지 않을때
    - 일단 동작부터 시켜야한다.
2. 시간이 너무 촉박할 때

## 02.리팩토링과 악취
#### 악취란
+ 이해하기 어려운 부분
+ 수정하기 어려운 부분
+ 확장하기 어려운 부분

## 03.리팩토링 에센스
1. 한번에 하나씩
    - 두 가지 이상의 수정을 한꺼번에 하지 않기
    - 되돌리기 쉽게 하기
    - 단계마다 확인
    - 오래된 것을 새로운 것으로 바꿈
    - 변수명은 직관적으로
- - -
## 리팩토링
#### 매직 넘버를 기호 상수로 치환
'입력 가능한 문자열의 길이는 100문자이하'는 제한이 있다고 했을 때 100이란 숫자를 조건 판단 부분에 직접 넣는건 좋지 않다
>숫자의 의미를 정확히 파악하기 힘들다.

매직넘버 대신에 `MAX_INPUT_LENGTH`처럼 기호상수를 쓰자
```java
if(100<input.length()){

}
```
이런 코드를 아래처럼 수정하자
```java
public class Something{
  public static final int MAX_INPUT_LENGTH =100;
}

if(Something.MAX_INPUT_LENGTH<input.length()){}
```
이렇게 되면 최대 길이가 변했을때 클래스 변수만 수정해 주면 된다.

**인다이렉션**
값 자체가 아닌 이름,주소 등을 사용하여 대상을 참조하는 기능.

1. 변수와 인디렉션
```java
for(int i = 0; i < 10 ; i++) {
system.out.println(i);
}
```
일반적으로 많이 사용되는 for문으로 1에서 9까지 출력을 하는 코드로
 1에서 9의 상수로 직접접근하지 않고 i라는 변수로 간접접근을 하고 있다.

2. 파일이름을 통한 인디렉션
단어의 길이를 출력하는 프로그램이 있다.
```java
String[] wordList = {"test1","test22","test333"};

for(String word : wordList) {
  system.out.println(word.length);
}
```
문자열의 내용이 달라지면 코드를 수정하게 된다.
이 부분을 파일로 분리하고 wordList만을 만들어 낸다면
어떤 단어의 파일만 오면 단어의 길이를 출력하게된다.

#### 리팩토링과 성능
**빠른 소프트웨어를 작성할 수 있는 일반적인 세 가지 방법**
1. 시간 분배
2. 성능에 꾸준한 관심
3. 성능 최적화 전까진 성능에 신경 쓰지 않고, 프로그램을 잘 쪼개진 방식으로 제작하는 것.

## 코드의 구린내
#### 중복코드
+ 똑같은 코드 구조가 두 군데 이상 있을 때는 기 부분을 하나로 통일
  + 메서드 추출 기법 후 메서드 상향기법 적용

**메서드 추출**
  ```java
  void printOwing(Double amount){
    printBanner();

    //세부 정보 출력
    System.out.println("name:" + name);
    System.out.println("amount:" + amount);
  }
  아래의 코드로 메서드 추출
  void printOwing(Double amount){
    printBanner();
    printDetails(amount);
  }
  void printDetails(Double amount){
    System.out.println("name:" + name);
    System.out.println("amount:" + amount);
  }
  ```
  **메서드 상향기법**
  ![메서드 상향](/assets/메서드%20상향.png)

#### 장황한 메서드
#### 방대한 클래스
#### 과다한 매개변수
#### 수정의 산발
#### 기능의 산재
#### 잘못된 소속
#### 데이터 뭉치
#### 강박적 기본 타입 사용
#### Switch 문
#### 평행 상속 계층
#### 직무유기 클래스
#### 막연한 범용 코드
#### 임시 필드
#### 메시지 체인
#### 과잉 중개 메서드
#### 지나친 관여
#### 인터페이스가 다른 대용 클래스
#### 미흡한 라이브러리 클래스
#### 데이터 클래스
#### 방치된 상속물
#### 불필요한 주석

## 테스트 작성
#### 자가 테스트 코드의 가치
#### JUnit 테스트 프레임워크
#### 테스트 추가

## 리팩토링 기법 카탈로그에 대해
#### 각 리팩토링 기법 절의 구성
#### 참조 검색
#### 리팩토링 기법의 성숙도
- - -
## 7장 객체 간의 기능 이동
**설계에서 중요 시 되는일 = 기능을 어디에 넣을지 판단**
#### 기능을 넣을 위치를 찾는 문제
+ 메서드 이동과 필드 이동을 실시하여 기능을 옮긴다.
  + 두 기법 모두 사용시 필드 이동부터 실시한 후 메서드 이동을 하는것이 좋다.

**클래스가 방대해 지는 원인**
+ 기능이 너무 많기 때문.
  + 클래스 추출을 실시해서 많은 기능들을 분리해야한다.
  + 리팩토링 기법 실시 후 결과 클래스에 기능이 너무 적어지면 클래스 내용을 직접 삽입하자.
`클래스 내용 직접 삽입 = 한 클래스의 기능을 다른 클래스로 합친다.`


#### 외래 클래스에 메서드 추가 기법
>클래스의 원본 코드에 접근할 수 없는 상황에서 이 수정 불가능한 클래스로 기능을 이동해야할때 실시
Method가 1~2개일 때 사용
#### 국소적 상속확장 클래스 사용 기법
>클래스의 원본 코드에 접근할 수 없는 상황에서 이 수정 불가능한 클래스로 기능을 이동해야할때 실시
Method가 3개 이상일 때 사용

#### 메서드 이동
>메서드가 자신이 속한 클래스보다 다른 클래스의 기능을 더 많이 이용할 때
그 메서드가 가장 많이 이용하는 클래스 안에서 비슷한 내용의 새 메서드를 작성하라.
기존의 메서드는 간단한 대리메서드로 바꾸던지 지우자.

메서드를 보고
그 <u>메서드를</u> 호출하는 메서드, 그 <u>메서드가</u> 호출하는 메서드, 상속 계층에서 그 메서드를 재정의하는 메서드를 살펴보자
- - -
**메서드 이동의 방법**
1. 원본 클래스에 정의도어 있는 원본 메서드에 사용된 모든 기능을 검사하자.(그 기능들도 전부 옮겨야 할지 판단)
2. 원본 클래스의 하위클래스와 상위클래스에서 그 메서드에 대한 다른 선언이 있는지 검사하자.
3. 그 메서드를 대상클래스 안에 선언하자.
4. 원본 메서드의 코드를 대상 메서드에 복사한 후, 대상 클래스 안에서 잘 돌아가게끔 대상 메서드를 약간 수정하자.
5. 대상 클래스를 컴파일하자.
6. 원본 객체에서 대상 객체를 참조할 방법을 정하자.
7. 원본 메서드를 위임 메서드로 전환하자.
8. 컴파일과 테스트를 실시.
9. 원본 메서드를 삭제하던지, 아니면 위임 메서드로 사용하게 내버려 두자.
10. 원본 메서드를 삭제할 때는 기존의 참조를 전부 대상 메서드 참조로 수정하자.
11. 컴파일과 테스트를 실시하자.
- - -
**필드 이동**
1. 필드가 public이면 필드 캡슐화 기법(getter/setter)을 실시
2. 컴파일과 테스트를 실시
3. 대상 클래스 안에 읽기/쓰기 메서드와 함꼐 필드를 작성하자.
4. 대상 클래스를 컴파일 하자
5. 원본 객체에서 대상 객체를 잠조할 방법을 정하자.
6. 원본 클래스에서 필드를 삭제하자.
7. 원본 필드를 참조하는 모든 부분을 대상 클래스에 있는 적절한 메서드를 참조하게 수정하자.
8. 컴파일과 테스트를 실시하자.
- - -
**클래스 추출**
+ 클래스의 어느 부분을 분리할지 궁리
  + 데이터의 일부분과 메서드의 일부분이 한 덩어리일 때.
  + 함께 변화하거나 서로 유난히 의존적인 데이터의 일부분일 때.
1. 클래스의 기능 분리 방법을 정하자.
2. 분리한 기능을 넣을 새 클래스를 작성하자.
3. 원본 클래스에서 새 클래스로의 링크를 만들자.
4. 옮길 필드마다 필드 이동을 적용하자
5. 필드를 하나씩 옮길 때마다 컴파일과 테스트를 실시하자.
6. 메서드 이동을 실시해서 원본 클래스의 메서드를 새 클래스로 옮기자. 하급 메서드부터 시작해서 상급 메서드에 적용하자.
7. 메서드 이동을 실시할 때마다 테스트를 실시하자.
8. 각 클래스를 다시 검사해서 인터페이스를 줄이자.
9. 여러 곳에서 클래스에 접근할 수 있게 할지 결정하자. 여러 곳에서 접근할 수 있게 할 경우, 새 클래스를 참조 객체나 변경불가 값 객체로서 공개할지 여부를 결정하자.*(접근제어자)*

````
접근제어자의 정도를 정하는 법
1. 모든 객체가 클래스의 어느 부분이든 변경할 수 있음을 받아들인다.
2.  이쪽은 이해가 잘 안되서 비워둠
3.  이쪽은 이해가 잘 안되서 비워둠
````
- - -
**클래스 내용 직접 삽입**
> 클래스 추출과 반대로 클래스가 더이상 정상적인 기능을 하지 못하여 존재 할 이유가 없을 때 실시한다.

1. 원본 클래스의 public 프로토콜 메서드를 합칠 클래스에 선언하고, 이 메서드를 전부 원본 클래스에 위임하자.
2. 원본 클래스의 모든 참조를 합칠 클래스로 참조로 수정하자.
3. 컴파일과 테스트를 실시하자.
4. 메서드 이동과 필드 이동을 실시해서 원본 클래스의 모든 기능을 합칠 클래스로 차례로 옮기자.
5. 원본 클래스를 삭제하자.
- - -
**대리 객체 은폐**
1. 대리 객체에 들어 있는 각 메서드를 대상으로 서버에 간단한 위임 메서드를 작성하자.
2. 클라이언트를 수정해서 서버를 호출하게 만들자.
3. 각 메서드를 수정할 때마다 컴파일과 테스트를 실시하자.
4. 대리 객체를 읽고 써야 할 클라이언트가 하나도 남지 않게 되면, 서버에서 대리 객체가 사용하는 읽기/쓰기 메서드를 삭제하자.
5. 컴파일과 테스트를 실시하자.
- - -
**과잉 중개 메서드 제거**
대리객체은폐의 반대이다
- - -
**외래 클래스에 메서드 추가**
>사용 중인 서버 클래스에 메서드를 추가해야 하는데 그 클래스를 수정할 수 없을 땐
클라이언트 클래스 안에 서버 클래스의 인스턴스를 첫 번째 인자로 받는 메서드를 작성하자.

1. 필요한 기능의 메서드를 클라이언트 클래스 안에 작성하자.
2. 서버 클래스의 인스턴스를 첫 번째 매개변수로 만들자.
3. 그 메서드에 '*서버 클래스에 있을 외래 메서드* ' 같은 주석을 달자.
- - -
**국소적 상속확장 클래스 사용**
>사용 중인 서버 클래스에 여러 개의 메서드를 추가해야 하는데 클래스를 수정할 수 없을 땐 새 클래스를 작성하고, 그 안에 필요한 여러 개의 메서드를 작성하자. 이 상속확장 클래스를 원본 클래스의 하위 클래스나 래퍼 클래스로 만들자.

1. 상속확장 클래스를 작성한 후 원본 클래스의 하위클래스나 래퍼 클래스로 만들자.
2. 상속확장 클래스에 변환 생성자 메서드를 작성하자.
3. 상속확장 클래스에 새 기능을 추가하자.
4. 필요한 위치마다 원본 클래스를 상속확장 클래스로 수정하자.
5. 이 클래스용으로 정의된 외래 메서드를 전부 상속확장 클래스로 옮기자.
