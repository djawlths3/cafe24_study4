# 리팩토링 개론

### 리팩토링
- 소프트웨어를 더 이해하기 쉽고 수정하기 쉽게 만드는 것
  - 겉으로 드러나는 기능에 거의 또는 아예 영향을 주지 않은 채 소프트웨어의 각종 기능을 변경할 수 있다.
- 겉으로 드러나는 소프트웨어 기능에 영향을 주지 않는다.
  - 따라서 리팩토링하기 전의 소프트웨어 기능은 리팩토링을 수행하고 나서도 그대로이며, 최종 사용자나 다른 프로그래머는 그 소프트웨어에 변화가 있음을 눈치채지 못한다.
- 코드를 추가하지 말고 코드 구조 개선만 해야 한다.

### 리팩토링은 왜 해야 하나
- 소프트웨어 설계가 개선되기 때문이다.
  - 부적절한 위치에 있는 코드를 제거한다.
  - 중복 코드를 없앤다. 이를 통해 코드 수정이 훨씬 쉬워진다.
- 소프트웨어를 이해하기가 더 쉬워진다.
  - 해당 코드를 나중에 수정하게 될 다른 개발자에 대해 고려하여 코드를 더 파악하기 쉽도록 한다.
  - 낯선 코드를 쉽게 이해할 수 있다.
  - 코드를 깔끔하게 만듦으로써 기존에 안 보이던 설계를 더욱 잘 볼 수 있다.
- 버그를 찾기 쉬워진다.
  - 프로그램 구조를 명료하게 만들어서 버그를 놓치지 않도록 한다.
- 프로그래밍 속도가 빨라진다.
  - 새 기능을 추가하거나 버그를 찾기 위해 많은 시간을 낭비하지 않아도 된다.
  - 리팩토링을 하지 않으면 시스템을 이해하고 중복 코드를 찾아내느라 수정 시간이 길어진다.

### 리팩토링은 어떨 때 필요한가
- 같은 작업의 삼진 아웃 때
  - 어떤 작업을 처음할 땐 그냥 하고, 비슷한 작업을 두 번째 해야 할 때도 그냥 하지만, 세 번째 하게 되면 리팩토링을 실시한다.
- 기능을 추가할 때
  - 리팩토링을 하면 더 이해하기 쉬워질지 충분히 고민한 후 확신이 들면 수행한다.
  - 설계가 지저분해서 어떤 기능을 추가하기 힘들 때 수행한다.
- 버그를 수정할 때
  - 버그 리포트가 입수되었을 때 수행한다.
- 코드를 검수할 때
  - 소규모 검수팀을 조직해 수정할 부분을 제안하고 그 수정 사항이 무리 없이 리팩토링될 수 있는지 판단하고, 문제가 없다면 수정 작업을 진행한다.

### 인다이렉션
- 코드에 있는 값을 바로 사용 하지 말고 그 값을 가리키는 포인터를 사용한라는 뜻
- 단점
  - 한 부분을 둘로 쪼개면 관리할 부분이 늘어난다.
  - 한 객체가 다른 객체에 작업을 위임하고 그 객체가 또 다른 객체에 작업을 위임하기 때문에 코드가 알아보기 힘들어질 수도 있다.
- 장점
  - 두 위치에서 호출되는 하위 메서드나 모든 하위클래스가 공유하는 상위클래스의 메서드 등이 있기 때문에 하나의 로직을 여러 곳에서 공유할 수 있다.
  - 내부 코드를 잘게 쪼개어 의도적인 측면에서 작성했다면 그 코드의 구조에 대한 대부분의 주요 정보를 잘 드러내는 코드를 작성할 수 있다.
  - 우선 하위클래스를 만들고 변하는 경우에 참조하게 만들면 다른 경우로 예기치 못하게 변할 위험을 검수하지 않고 클래스를 수정할 수 있다.
  - 조건문을 메시지로 바꾸면 중복 코드가 줄어들어 명료해지며 동시에 유연성도 높아진다.
- 기존에 어떤 목적으로 사용됐는제 현재는 쓸모 없게 된 중개 메서드, 또는 원래 공유하거나 재정의할 계획이었으나 결국 한 곳에만 사용하게 바꾼 컴포넌트가 주로 발견되는 인다이렉션이기 때문에 제거한다.

### 리펙토링 관련 문제들
- 데이터베이스
  - 수많은 애플리케이션은 바탕이 되는 데이터베이스 스키마와 강력히 결합되어 있다.
  - 이러한 강결합을 해결하기 위해 객체 모델과 데이터베이스 모델 사이에 별도의 소프트웨어 계층을 두는 방법이 있다.
  - 객체 모델의 일정 부분들이 변경될 가능성이 높다는 사실을 깨달았을 때 별도의 계층을 생성한다.
  - 만약 수동으로 마이그레이션을 실시하면 시간이 오래 걸릴 수 있다.
- 인터페이스 변경
  - 상당수의 리팩토링이 인터페이스를 건드린다.
  - 인터페이스가 사용되는 부분을 찾는 게 불가능하거나 수정할 수 없을 경우 문제가 발생할 수 있다.
  - 이러한 문제를 해결하기 위해 기존 인터페이스와 새 인터페이스를 모두 유지시킨다.
  - 그 후 기존 인터페이스가 새 인터페이스를 호출하게 만든다.
  - 인터페이스를 사용하는 부분이 그 인터페이스 변경에 맞춰 수정되기 전까지 유지시킨다.
- 리팩토링을 어렵게 하는 설계를 수정하는 일
  - 설계 자체에 오류가 있을 때나 설계에 대한 결정이 나중에 바뀌었을 때, 혹은 수정하기 힘들 것 같은 민감한 부분일 때도 리팩토링으로 해결할 수 있다.

### 리팩토링을 하면 안 되는 상황
- 코드를 처음부터 작성할 때
  - 코드는 반드시 대부분 제대로 돌아가는 것이 우선이고, 리팩토링은 나중 일이다.
  - 거대한 소프트웨어를 여러 개의 컴포넌트로 나누고 한 개의 컴포넌트씩 리팩토링할지 코드를 새로 작성할지를 결정한다.
- 납기가 임박했을 때
  - 이러한 경우가 아니라면 시간이 없다는 핑계로 리팩토링을 미루지 않도록 한다.

### 리팩토링과 성능
- 리팩토링을 실시하면 단기적으로는 소프트웨어가 더 느려질 가능성이 있지만, 최적화를 거치면서 소프트웨어 성능을 더 간단히 조절할 수 있다.
  - 성능 튜닝에 할애할 시간이 생긴다. 코드가 잘 쪼개져 있어서 기능 추가도 더 신속히 이뤄진다. 그로 인해 더 많은 시간을 성능에만 집중할 수 있다.
  - 성능을 분석할 때 더 정밀한 분석이 가능해진다. 더 작은 코드 부분을 찾아주기 때문에 튜닝이 더 쉬워지고, 어느 튜닝이 효과가 있을 지에 대해서도 좀 더 확실히 판단할 수 있다.

# 코드의 구린내 - 리팩토링이 필요한 시점

### 중복 코드
- 똑같은 코드 구조가 두 군에 이상 있을 때는 그 부분을 하나로 통일한다.
  - 한 클래스의 두 메서드 안에 같은 코드가 들어있는 경우 겹치는 코드를 빼내어 별도의 메서드로 만들고 그 메서드를 두 곳에서 호출한다.
  - 한 클래스의 두 하위클래스에 같은 코드가 들어 있는 경우
  - 서로 상관없는 두 클래스 안에 중복 코드가 있을 때는 제 3의 클래스나 모듈로 떼어낸 후 그것을 다른 클래스에서 호출한다. 아니면 중복 코드를 빼서 메서드로 만든 후 그 메서드를 두 클래스 중 하나에 넣고 다른 클래스에서 그 메서드를 호출한다.

### 장황한 메서드
- 짧은 메서드를 이해하기 쉽게 하기 위해 메서드명을 잘 정한다.
  - 기능 수행 방식이 아니라 목적(즉, 기능 자체)을 나타내는 이름으로 정한다.
  - 메서드 호출이 원래 코드보가 길어지는 한이 있어도, 메서드명은 그 코드의 의도를 잘 반영하는 것으로 정한다.
- 이를 위해서 메서드를 훨씬 과감하게 쪼갠다.
- 코드를 여러 덩이로 분리하기 위해 기능 설명이 주석으로 처리된 코드 구간을 메서드로 만든다.
- 조건문과 루프도 역시 메서드로 뺀다.

### 방대한 클래스
- 클래스에 인스턴스 변수가 너무 많으면 중복 코드가 반드시 존재하게 마련이다.
  - 한 클래스 안의 일부 변수가 접두어나 접미어가 같다면 하나의 클래스로 추출하는 게 좋다.
- 코드 분량이 너무 방대한 클래스에도 중복 코드가 많이 있기 마련이다.
- 만약 방대한 클래스가 GUI 클래스라면 데이터와 기능을 서로 다른 도메인 객체로 옮겨야 할 수도 있다.
  - 이를 위해 두 곳에 있는 일부 중복 데이터는 놔두고 그 데이터와 싱크를 유지해야할 수도 있다.
  - 구 버전의 AWT 컴포넌트를 사용한다면 GUI 클래스를 없애고 Swing 컴포넌트로 대체한다.

### 과다한 매개변수
- 객체를 사용할 때는 메서드에 필요한 모든 데이터를 전달하는 게 아니라 그 모든 데이터를 가져올 수 있는 메서드만 전달하면 된다.
  - 메서드가 필요로 하는 각종 데이터는 그 메서드가 속한 클래스에 들어 있다.

### 수정의 산발
- 수정할 때 개발자는 시스템의 분명한 위치로 곧장 가서 수정할 수 있어야 한다.
- 한 클래스가 다양한 원인 때문에 다양한 방식으로 자주 수정될 때 일어난다.
  - 만약  하나의 클래스에서 새 데이터베이스를 생성할 때마다 3개의 메서드를 수정해야 하고, 새 금융 상품을 추가할 때마다 4개의 메서드를 수정해야 한다는 생각이 들면 그 하나의 클래스를 여러 개의 변형 객체로 분리하는 것이 좋다.
- 변경이 이루어질 때는 한 개의 클래스나 모듈만 변경해야 하며, 새 클래스나 모듈 안에는 반드시 그 변경사항을 표시해야 한다.

### 기능의 산재
- 수정할 때마다 여러 클래스에서 수 많은 자잘한 부분을 고쳐야 한다면 이 문제를 의심할 수 있다.
- 수정할 부분이 여기저기에 있다면 찾기도 힘들 뿐더러 꼭 수정해야 하는 부분을 놓치기 쉽다.
- 문제 해결을 위해 수정할 부분들을 전부 하나의 클래스 안에 넣는다.
- 기존의 클래스 중 어느 것에 넣기에도 부적절해 보일 때는 새 클래스를 만든다.
- 별도 클래스에 분산되어 있던 모든 기능을 한 곳으로 가져와도 된다.

### 잘못된 소속
- 어떤 메서드가 자신이 속하지 않은 클래스에 더 많이 접근한다면 잘못된 소속을 의심해 볼 수 있다.
- 잘못 소속된 메서드가 제일 흔히 접근하는 대상은 데이터다.
- 소속이 잘못된 메서드는 더 많이 접근하는 클래스로 옮기도록 한다.
- 한 메서드가 여러 클래스에 들어 있는 기능을 이용할 때는 문제의 메서드가 접근하는 데이터가 어느 클래스에 제일 많이 들어 있는지 파악해서 그 클래스로 옮긴다.

### switch 문
- switch 문의 단점은 반드시 중복이 생긴다는 점이다.
- 이 문제를 해결할 수 있는 최상의 방법 중 하나는 다형성, 즉 재정의를 이용하는 것이다.
- 대부분의 switch 문은 고민할 필요 없이 재정의로 바꿔야 한다.
- 하나의 메서드에 영향을 미치는 case 문이 2~3개 밖에 없고 나중에 그 모든 case 문을 수정할 일이 없을 것 같으면, 재정의로 전환하는 것은 과하다.

### 평행 상속 계층
- 기능의 산재의 특수한 상황이다.
- 이 문제점이 있으면 한 클래스의 하위클래스를 만들 때마다 매번 다른 클래스의 하위클래스도 만들어야 한다.
- 서로 다른 두 상속 계층의 클래스명 접두어가 같으면 이 문제를 의심할 수 있다.
- 중복 코드 부분을 제거하려면 보통은 한 상속 계층의 인스턴스가 다른 상속 계층의 인스턴스를 참조하게 만들면 된다.

### 직무유기 클래스
- 비용만큼의 기능을 수행하지 못하는 비효율적 클래스를 없앤다.
- 기존에는 비용 대비 효율성이 좋았으나 리팩토링 실시로 인해 기능이 축소된 클래스, 또는 수정할 계획으로 작성했으나 수정을 실시하지 않아 쓸모없어진 클래스가 직무유기 클래스에 해당된다.

### 막연한 범용 코드
- 조만간 이런 기능이 필요하겠구나 라는 막연한 생각으로 온갖 호출과 case문을 넣지 않도록 한다.
- 메서드나 클래스가 오직 테스트 케이스에만 사용되는 경우도 막연한 범용 코드일 가능성이 높다.
  - 이러한 메서드나 클래스를 발견하면 그것과 그것을 실행하는 테스트 케이스를 모두 삭제한다.
  - 단, 적절한 기능을 실행하는 테스트 케이스용 헬퍼 메서드나 클래스는 당연히 삭제하지 말고 내버려둔다.

### 임시 필드
- 어떤 객체 안에 인스턴스 변수가 특정 상황에서만 할당되는 경우가 간혹 있다.
- 복잡한 알고리즘에 여러 변수를 사용해야 할 때 가끔 발생한다.

### 불필요한 주석
- 엄청난 양의 주석이 달린 코드를 보면 그 주석들이 해당 코드의 좋지 않은 부분을 가리기 위해 존재하는 경우가 상당히 많다.
- 대체로 리팩토링을 마친 후에야 그 주석들이 불필요한 것이었다는 사실을 알게 된다.
- 주석을 넣어야겠다는 생각이 들 땐 먼저 코드를 리팩토링해서 주석을 없앨 수 있게 만드는 것이 좋다.
- 주석은 무슨 작업을 해야 좋을지 모를 때만 넣는 것이 좋다.
- 주석은 돌아가는 원리, 확실치 않은 부분, 어떤 코드를 넣은 이유를 메모해 놓는 용도로 사용한다.

# 테스트 작성

### 자가 테스트 코드의 가치
- 테스트 코드를 작성하지 않으면 해야 할 작업을 파악하거나 설계하는 시간은 얼마 안 되고 디버깅하는 시간이 대부분을 차지할 수 있다.
- 모든 테스트를 완전히 자동화하고 결과를 자체적으로 검사하게 하는 것이 좋다.
- 지속적인 테스트 코드 작성과 이를 이용해 테스트를 진행 한다면 버그가 직전에 작성한 코드임을 알 수 있고 버그를 찾기도 쉬워진다.
  - 함수 하나를 완성할 때마다 끝 부분에 테스트를 넣으면 버그가 생기더라도 예전에 작성한 코드의 문제가 아닌 직전에 작성한 코드가 문제임을 알 수 있다.
- 테스트를 작성할 때 고의적인 버그를 넣는 것도 좋은 방법이다.

### 단위 테스트와 기능 테스트
- 단위 테스트의 목적은 프로그래밍 생산성 향상이다.
- 단위 테스트는 매우 국소적이어서, 각 테스트 클래스는 하나의 패키지 안에서만 효력이 있다.
- 다른 패키지의 인터페이스를 테스트하지만, 그 외에 나머지 코드는 잘 돌아간다고 가정한다.
- 기능 테스트의 목적은 소프트웨어 전반이 제대로 돌아가는지 확인하는 것이다.
- 기능 테스트는 고객에게 품질 보증만 할 뿐 프로그래머의 생산성과는 무관하다.
- 따라서 기능 테스트 코드는 별도의 버그 발견 전문 팀이 개발해야 한다.

### 테스트 추가
- 클래스가 수행해야 할 모든 작업을 파악하고 그 클래스가 실패할 만한 모든 조건마다 각 작업을 테스트하는 것이 좋다.
- 테스트는 위험이 있는 곳에만 집중시켜서 테스트코드 작성의 부담감을 줄이도록 한다.
  - 코드에서 복잡해지는 부분이 어딘지를 파악하고, 함수를 살펴보면서 에러 가능성이 높은 부분들을 생각한다.
- 읽기, 쓰기 메서드는 너무 간단해서 버그가 있을 확률이 거의 없기 때문에 테스트를 안해도 될 수 있다.
- 잘못될까봐 가장 걱정되는 부분들만 테스트한다.
- 완벽한 테스트를 작성하려다 아예 테스트를 포기하느니, 차라리 불완전한 테스트를 작성해 실행하는 편이 낫다.
- 잘못될 수 있는 경계 조건을 생각한 후, 그 상황에서의 테스트에 집중한다.
- 테스트를 실시할 때는 반드시 예상한 에러가 제대로 발생하는지 검사해야 한다.
  - 뭔가 에러가 있으리라 예상될 땐 그 예외가 정말로 발생하는지 꼭 테스트 하도록 하자.
- 객체에 한가지 단점은 상속과 재정의로 인해 테스트할 조합이 너무 많아져서 테스트가 어려워질 수 있다는 점이다.
  - 나올 수 있는 모든 조합을 테스트하진 않고, 각 조합 후보 클래스만 테스트를 실시하도록 한다.

### JUnit 테스트 프레임워크
- 테스트 코드를 추가하려면 먼저 생성자를 작성해야 한다.
```java
public class FileReaderTester extends TestCase {

	public FileReaderTester(String name) {
		super(name);
	}
}
```
- 테스트 픽스처를 구성한다. 테스트 픽스처란 기본적으로 테스트의 샘플 역할을 하는 객체를 일컫는다.
  - 해당 예제는 파일을 읽는 코드이므로 데이터 샘플이 들어있는 txt 파일을 만든다.
  - data.txt
```
Bradman	99.94	52	80	10	6996	334	29
Pollock	60.97	23	41	4	2256	274	7
Headley	60.83	22	40	4	2256	270*	10
Sutcliffe	60.73	54	84	9	4555	194	16
```
- setUp 메서드는 픽스처 객체를 생성하고 tearDown 메서드는 픽스처 객체를 제거한다.
  - yearDown 메서드는 거의 사용할 일이 없지만, 파일을 닫을 때 사용하면 좋다.
```java
public class FileReaderTester extends TestCase {
	
	private FileReader _input;

	// ...

	protected void setUp() {
		try {
			_input = new FileReader("C:/data.txt");
		}catch(FileNotFoundException e){
			throw new RuntimeException("테스트 파일을 열 수 없음");
		}
	}
	
	protected void tearDown() {
		try {
			_input.close();
		}catch(IOException e) {
			throw new RuntimeException("테스트 파일을 닫는 중 에러 발생");
		}
	}
}
```
- 읽기 메서드를 테스트 한다. 다음과 같이 두세 개 정도의 문자를 읽은 후 그 다음에 읽은 문자가 맞는 문자인지 검사한다.
  - 자동 테스트는 assert 메서드가 담당한다.
  - assert 메서드의 반환 값이 true이면 테스트에 성공한 것이고 그렇지 않으면 에러가 있다는 뜻이다.
```java
public class FileReaderTester extends TestCase {

	// ...

	public void testRead() throws IOException{
		// Bradman ...
		char ch = '&';
		for(int i=0; i<4; i++) {
			ch = (char)_input.read();
		}
		assert('d' == ch);
	}
}
```
- testRead에서 assert 대신 assertEquals 메서드를 사용하면 좀 더 개선된 에러 문구가 출력된다.
```java
	public void testRead3() throws IOException{
		// Bradman ...
		char ch = '&';
		for(int i=0; i<4; i++) {
			ch = (char)_input.read();
		}
		assertEquals('m', ch);
	}
```
- 테스트를 실행하기 위해 별도의 TestRunner 클래스를 사용한다.
  - FileReaderTester 클래스를 테스트한다.
  - 해당 클래스 내에서 test로 시작하는 모든 메서드에 대해 자동으로 테스트를 진행한다.
  - 에러가 없다면 OK 출력 문구를 볼 수 있다.
```java
public class FileReaderTester extends TestCase {

	// ...

	public static void main(String[] args) {
		junit.textui.TestRunner.run(new TestSuite(FileReaderTester.class));
	}
}
```
- 여러 테스트 케이스를 작성한다.
```java
public class FileReaderTester extends TestCase {

	// ...

	public void testRead2() throws IOException{
		// Bradman ...
		char ch = '&';
		for(int i=0; i<4; i++) {
			ch = (char)_input.read();
		}
		assert('2' == ch);
	}

	public void testReadAtEnd() throws IOException{
		int ch = -1234;
		for(int i=0; i<141; i++)
			ch = _input.read();
		assertEquals("read at end", -1, _input.read());
	}

	// ...
}
```
- 테스트 케이스를 작성할 때는 각 바운더리의 예상 값을 테스트 하는 것이 좋다.
```java
	public void testReadBoundaries() throws IOException{
		assertEquals("read first char", 'B', _input.read());
		int ch;
		for(int i=1; i<140; i++) {
			ch = _input.read();
		}
		assertEquals("read last char", '6', _input.read());
		assertEquals("read at end", -1, _input.read());
	}
```

# 리팩토링 기법 카탈로그에 대해
- 6장~12장이 리팩토링 기법을 하나씩체계적으로 설명하는 카탈로그 형식으로 구성되어 있다.

### 각 리팩토링 기법 절의 구성
- 이름 : 각종 리팩토링 기법을 구별하기 위한 필수적인 요소이며 카탈로그의 각 절 제목으로도 사용했다.
- 요약 : 기법의 적용 시점과 목적을 설명한다. 이 부분을 보면 자신에게 필요한 리팩토링 기법을 더 빨리 찾을 수 있다.
  - 해당 리팩토링을 통해 해결할 수 있는 문제, 리팩토링 목표, 리팩토링 전후의 간단한 사례 예시
- 동기 : 기법을 실시하는 이유와 실시하지 말아야 할 경우를 설명한다.
- 방법 : 기법을 수행하는 절차를 단계적으로 간단명료하게 설명한다.
- 예제 : 기법의 원리를 이해하도록 간단한 리팩토링 사례를 보여준다.
- 해당 책이 수록한 기법은 싱글 프로세스 소프트웨어를 염두에 두고 설명한 것이다. 그렇기 때문에 병렬 프로그래밍과 분산 프로그래밍에서의 사용법을 다룬 리팩토링 책이 아니다.
  - ex) 싱글 프로세스 소프트웨어에선 메서드를 호출하는 횟수는 중요하지 않다.
